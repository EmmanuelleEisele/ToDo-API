import request from 'supertest';
import app from '../../index.js';
import User from '../../src/models/User.js';
import RefreshToken from '../../src/models/RefreshToken.js';
import argon2 from 'argon2';
import jwt from 'jsonwebtoken';

describe('Tests JWT et Refresh Tokens', () => {
  let testUser;
  let validToken;
  let refreshToken;
  let userId;

  // Cr√©er un utilisateur de test avant chaque test
  beforeEach(async () => {
    const hashedPassword = await argon2.hash('password123');
    testUser = new User({
      firstname: 'Test',
      lastname: 'JWT',
      email: 'jwt@test.com',
      password: hashedPassword
    });
    await testUser.save();
    userId = testUser._id;
  });

  describe('üîë G√©n√©ration et Validation des JWT', () => {
    
    it('devrait g√©n√©rer un token JWT valide lors du login', async () => {
      const response = await request(app)
        .post('/auth/login')
        .send({
          email: 'jwt@test.com',
          password: 'password123'
        })
        .expect(200);

      // V√©rifier que le token est pr√©sent
      expect(response.body).toHaveProperty('token');
      expect(typeof response.body.token).toBe('string');
      expect(response.body.token.length).toBeGreaterThan(20);

      // V√©rifier que le token peut √™tre d√©cod√©
      const decoded = jwt.verify(response.body.token, process.env.JWT_SECRET);
      expect(decoded).toHaveProperty('id');
      expect(decoded.id).toBe(userId.toString());
      
      validToken = response.body.token;
    });

    it('devrait rejeter un token JWT invalide', async () => {
      const fakeToken = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpZCI6ImZha2UiLCJpYXQiOjE2MDAwMDAwMDAsImV4cCI6MTYwMDAwMzYwMH0.fake_signature';
      
      const response = await request(app)
        .get('/tasks')
        .set('Authorization', `Bearer ${fakeToken}`)
        .expect(401);

      expect(response.body).toHaveProperty('status', 'fail');
      expect(response.body.message).toMatch(/token.*invalide/i);
    });

    it('devrait rejeter un token JWT expir√©', async () => {
      // Cr√©er un token expir√© (exp dans le pass√©)
      const expiredToken = jwt.sign(
        { id: userId.toString() }, 
        process.env.JWT_SECRET, 
        { expiresIn: '-1h' } // Expir√© depuis 1h
      );

      const response = await request(app)
        .get('/tasks')
        .set('Authorization', `Bearer ${expiredToken}`)
        .expect(401);

      expect(response.body).toHaveProperty('status', 'fail');
      expect(response.body.message).toMatch(/token.*expir√©/i);
    });

    it('devrait rejeter un token avec une signature incorrecte', async () => {
      // Cr√©er un token avec une mauvaise signature
      const tokenWithWrongSecret = jwt.sign(
        { id: userId.toString() }, 
        'mauvaise_signature', 
        { expiresIn: '1h' }
      );

      const response = await request(app)
        .get('/tasks')
        .set('Authorization', `Bearer ${tokenWithWrongSecret}`)
        .expect(401);

      expect(response.body).toHaveProperty('status', 'fail');
    });

    it('devrait rejeter un token avec un utilisateur inexistant', async () => {
      const fakeUserId = '507f1f77bcf86cd799439011';
      const tokenWithFakeUser = jwt.sign(
        { id: fakeUserId }, 
        process.env.JWT_SECRET, 
        { expiresIn: '1h' }
      );

      const response = await request(app)
        .get('/tasks')
        .set('Authorization', `Bearer ${tokenWithFakeUser}`)
        .expect(401);

      expect(response.body).toHaveProperty('status', 'fail');
    });
  });

  describe('üîÑ Gestion des Refresh Tokens', () => {
    
    it('devrait cr√©er un refresh token lors du login', async () => {
      const response = await request(app)
        .post('/auth/login')
        .send({
          email: 'jwt@test.com',
          password: 'password123'
        })
        .expect(200);

      // V√©rifier que le cookie refresh token est pr√©sent
      const cookies = response.headers['set-cookie'];
      expect(cookies).toBeDefined();
      
      const refreshCookie = cookies.find(cookie => 
        cookie.startsWith('refreshToken=')
      );
      expect(refreshCookie).toBeDefined();
      
      // V√©rifier les propri√©t√©s du cookie
      expect(refreshCookie).toMatch(/HttpOnly/);
      expect(refreshCookie).toMatch(/SameSite=Strict/);
    });

    it('devrait stocker le refresh token en base de donn√©es', async () => {
      await request(app)
        .post('/auth/login')
        .send({
          email: 'jwt@test.com',
          password: 'password123'
        })
        .expect(200);

      // V√©rifier qu'un refresh token existe en BDD
      const refreshTokenInDB = await RefreshToken.findOne({ userId: userId });
      expect(refreshTokenInDB).toBeTruthy();
      expect(refreshTokenInDB.token).toBeDefined();
      expect(refreshTokenInDB.userId.toString()).toBe(userId.toString());
    });

    it('devrait supprimer le refresh token lors du logout avec cookie', async () => {
      // Se connecter d'abord
      const loginResponse = await request(app)
        .post('/auth/login')
        .send({
          email: 'jwt@test.com',
          password: 'password123'
        });

      const cookies = loginResponse.headers['set-cookie'];
      const refreshCookie = cookies.find(cookie => 
        cookie.startsWith('refreshToken=')
      );

      // V√©rifier que le refresh token existe
      let refreshTokenInDB = await RefreshToken.findOne({ userId: userId });
      expect(refreshTokenInDB).toBeTruthy();

      // Se d√©connecter avec le cookie (comme le fait vraiment votre app)
      await request(app)
        .post('/auth/logout')
        .set('Cookie', refreshCookie)
        .expect(200);

      // V√©rifier que le refresh token a √©t√© supprim√©
      refreshTokenInDB = await RefreshToken.findOne({ userId: userId });
      expect(refreshTokenInDB).toBeNull();
    });

    it('devrait remplacer l\'ancien refresh token lors d\'un nouveau login', async () => {
      // Premier login
      await request(app)
        .post('/auth/login')
        .send({
          email: 'jwt@test.com',
          password: 'password123'
        });

      const firstRefreshToken = await RefreshToken.findOne({ userId: userId });
      const firstToken = firstRefreshToken.token;
      const firstTokenId = firstRefreshToken._id;

      // Attendre un peu pour s'assurer que le timestamp sera diff√©rent
      await new Promise(resolve => setTimeout(resolve, 100));

      // Deuxi√®me login
      await request(app)
        .post('/auth/login')
        .send({
          email: 'jwt@test.com',
          password: 'password123'
        });

      // V√©rifier qu'il n'y a qu'un seul refresh token (votre logique supprime puis recr√©e)
      const allRefreshTokens = await RefreshToken.find({ userId: userId });
      expect(allRefreshTokens).toHaveLength(1);
      
      // Le nouveau token devrait avoir un ID diff√©rent (car supprim√© puis recr√©√©)
      const secondRefreshToken = allRefreshTokens[0];
      expect(secondRefreshToken._id.toString()).not.toBe(firstTokenId.toString());
    });
  });

  describe('üõ°Ô∏è S√©curit√© des Tokens', () => {
    
    it('devrait avoir des tokens avec des ID utilisateur corrects', async () => {
      const response = await request(app)
        .post('/auth/login')
        .send({
          email: 'jwt@test.com',
          password: 'password123'
        });

      const token = response.body.token;
      const decoded = jwt.decode(token);
      
      expect(decoded.id).toBe(userId.toString());
      expect(decoded.iat).toBeDefined(); // issued at
      expect(decoded.exp).toBeDefined(); // expires at
      expect(decoded.exp).toBeGreaterThan(decoded.iat);
    });

    it('ne devrait pas exposer d\'informations sensibles dans le token', async () => {
      const response = await request(app)
        .post('/auth/login')
        .send({
          email: 'jwt@test.com',
          password: 'password123'
        });

      const token = response.body.token;
      const decoded = jwt.decode(token);
      
      // V√©rifier que le password n'est pas dans le token
      expect(decoded).not.toHaveProperty('password');
      expect(decoded).not.toHaveProperty('email');
      expect(decoded).not.toHaveProperty('firstname');
      expect(decoded).not.toHaveProperty('lastname');
    });

    it('devrait utiliser le bon format Bearer pour l\'authentification', async () => {
      // Se connecter pour obtenir un token
      const loginResponse = await request(app)
        .post('/auth/login')
        .send({
          email: 'jwt@test.com',
          password: 'password123'
        });

      const token = loginResponse.body.token;

      // Tester avec Bearer
      const validResponse = await request(app)
        .get('/tasks')
        .set('Authorization', `Bearer ${token}`)
        .expect(200);

      // Tester sans Bearer (devrait √©chouer)
      const invalidResponse = await request(app)
        .get('/tasks')
        .set('Authorization', token)
        .expect(401);

      expect(invalidResponse.body).toHaveProperty('status', 'fail');
    });
  });

  describe('‚è∞ Expiration et Dur√©e de Vie', () => {
    
    it('devrait avoir une dur√©e d\'expiration raisonnable', async () => {
      const response = await request(app)
        .post('/auth/login')
        .send({
          email: 'jwt@test.com',
          password: 'password123'
        });

      const token = response.body.token;
      const decoded = jwt.decode(token);
      
      const now = Math.floor(Date.now() / 1000);
      const expiresIn = decoded.exp - decoded.iat;
      
      // V√©rifier que le token expire dans un d√©lai raisonnable (ex: 1h = 3600s)
      expect(expiresIn).toBeGreaterThan(0);
      expect(expiresIn).toBeLessThanOrEqual(3600); // Max 1h
      expect(decoded.exp).toBeGreaterThan(now); // Pas encore expir√©
    });

    it('devrait permettre l\'acc√®s avec un token fra√Æchement g√©n√©r√©', async () => {
      const response = await request(app)
        .post('/auth/login')
        .send({
          email: 'jwt@test.com',
          password: 'password123'
        });

      const token = response.body.token;

      // Utiliser imm√©diatement le token
      const tasksResponse = await request(app)
        .get('/tasks')
        .set('Authorization', `Bearer ${token}`)
        .expect(200);

      expect(tasksResponse.body).toHaveProperty('message');
      expect(tasksResponse.body).toHaveProperty('data');
    });
  });

  describe('üîí Tests de Concurrence et Edge Cases', () => {
    
    it('devrait g√©rer plusieurs logins simultan√©s', async () => {
      const promises = Array(3).fill().map(() => 
        request(app)
          .post('/auth/login')
          .send({
            email: 'jwt@test.com',
            password: 'password123'
          })
      );

      const responses = await Promise.all(promises);

      // Tous les logins devraient r√©ussir
      responses.forEach(response => {
        expect(response.status).toBe(200);
        expect(response.body).toHaveProperty('token');
      });

      // En cas de concurrence, il peut y avoir plusieurs tokens temporairement
      // Votre syst√®me fait deleteMany puis create, mais la concurrence peut cr√©er des doublons
      const refreshTokens = await RefreshToken.find({ userId: userId });
      expect(refreshTokens.length).toBeGreaterThan(0);
      expect(refreshTokens.length).toBeLessThanOrEqual(3); // Pas plus que les requ√™tes simultan√©es
    });

    it('devrait supprimer les refresh tokens apr√®s logout', async () => {
      // Se connecter
      const loginResponse = await request(app)
        .post('/auth/login')
        .send({
          email: 'jwt@test.com',
          password: 'password123'
        });

      const token = loginResponse.body.token;
      const cookies = loginResponse.headers['set-cookie'];
      const refreshCookie = cookies.find(cookie => 
        cookie.startsWith('refreshToken=')
      );

      // V√©rifier que le token fonctionne
      await request(app)
        .get('/tasks')
        .set('Authorization', `Bearer ${token}`)
        .expect(200);

      // Se d√©connecter avec le cookie (m√©thode r√©elle)
      await request(app)
        .post('/auth/logout')
        .set('Cookie', refreshCookie)
        .expect(200);

      // Le JWT devrait encore fonctionner (stateless par nature)
      await request(app)
        .get('/tasks')
        .set('Authorization', `Bearer ${token}`)
        .expect(200);

      // Mais le refresh token devrait √™tre supprim√© de la BDD
      const refreshTokens = await RefreshToken.find({ userId: userId });
      expect(refreshTokens).toHaveLength(0);
    });
  });
});

/*
üìö GUIDE DES TESTS JWT/REFRESH TOKENS :

üîë TESTS JWT :
- G√©n√©ration de token valide
- Validation de la signature
- Gestion de l'expiration
- Format Bearer correct
- Contenu s√©curis√© (pas de donn√©es sensibles)

üîÑ TESTS REFRESH TOKENS :
- Cr√©ation lors du login
- Stockage en base de donn√©es
- Suppression lors du logout
- Remplacement lors de nouveaux logins
- Unicit√© par utilisateur

üõ°Ô∏è TESTS S√âCURIT√â :
- Tokens avec utilisateurs inexistants
- Signatures incorrectes
- Tokens expir√©s
- Format d'autorisation
- Concurrence et edge cases

‚è∞ TESTS DUR√âE DE VIE :
- Expiration raisonnable
- Utilisation imm√©diate
- Validation de la chronologie

üí° BONNES PRATIQUES TEST√âES :
- HttpOnly cookies pour refresh tokens
- SameSite=Strict pour la s√©curit√©
- JWT stateless (pas de r√©vocation c√¥t√© serveur)
- Un seul refresh token par utilisateur
- Nettoyage des tokens lors du logout
*/